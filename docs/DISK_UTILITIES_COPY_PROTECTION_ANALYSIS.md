# Disk-Utilities Copy Protection Analysis Report

**Date:** 2026-01-04  
**Source:** disk-utilities-master.zip (Keir Fraser)  
**Analysis for:** UFT v3.6.0.017

---

## Executive Summary

Disk-utilities by Keir Fraser is **THE definitive reference implementation** for Amiga copy protection handling. With **456 track type definitions** and **~52,000 LOC**, it represents decades of reverse engineering work on copy protection schemes.

**Key Value for UFT:**
1. **456 protection types** - Complete Amiga protection encyclopedia
2. **36+ longtrack variants** - Comprehensive long track implementations  
3. **CopyLock LFSR** - Complete Rob Northen protection with timing
4. **Weak bit handling** - Dungeon Master/Chaos Strikes Back reference
5. **Speedlock** - Variable density track detection

---

## 1. Architecture Overview

### 1.1 Core Components

```
libdisk/
├── container/      # Format containers (ADF, HFE, IPF, SCP, etc.)
├── format/
│   ├── amiga/      # 194 Amiga protection handlers (!)
│   ├── ibm.c       # IBM MFM formats
│   └── raw.c       # Raw track handling
├── stream/         # Flux stream sources (KryoFlux, SCP, CAPS)
└── include/
    └── libdisk/
        └── track_types.h  # 456 track type definitions
```

### 1.2 Track Handler Interface

```c
struct track_handler {
    enum track_density density;
    unsigned int bytes_per_sector;
    unsigned int nr_sectors;
    void (*get_name)(struct disk *, unsigned int tracknr, char *, size_t);
    void *(*write_raw)(struct disk *, unsigned int tracknr, struct stream *);
    void (*read_raw)(struct disk *, unsigned int tracknr, struct tbuf *);
    void *(*write_sectors)(struct disk *, unsigned int tracknr, struct track_sectors *);
    void (*read_sectors)(struct disk *, unsigned int tracknr, struct track_sectors *);
    void *extra_data;
};
```

### 1.3 Track Buffer API

```c
// Bitcell encoding types
enum bitcell_encoding {
    bc_raw,           // Raw bits, no clock insertion
    bc_mfm,           // MFM with automatic clock bits
    bc_mfm_even,      // Even-numbered data bits only
    bc_mfm_odd,       // Odd-numbered data bits only
    bc_mfm_even_odd,  // Even then odd (Amiga style)
    bc_mfm_odd_even   // Odd then even
};

// Track buffer functions
void tbuf_bits(struct tbuf *, uint16_t speed, enum bitcell_encoding enc, 
               unsigned int bits, uint32_t x);
void tbuf_bytes(struct tbuf *, uint16_t speed, enum bitcell_encoding enc,
                unsigned int bytes, void *data);
void tbuf_gap(struct tbuf *, uint16_t speed, unsigned int bits);
void tbuf_weak(struct tbuf *, unsigned int bits);  // ← WEAK BIT SUPPORT!
```

---

## 2. CopyLock Protection (Rob Northen)

### 2.1 Track Structure

```c
/* RAW TRACK LAYOUT:
 *  518 decoded bytes per sector (excluding sector gap)
 *  Inter-sector gap of ~44 decoded zero bytes (44 MFM words).
 * 
 * Decoded Sector:
 *  u8 0xa0+index,0,0 :: First byte is MFM-illegal for TRKTYP_copylock_old
 *  <sync word>       :: Per-sector sync marker
 *  u8 index          :: 0-11, must correspond to sync marker
 *  u8 data[512]
 *  u8 0
 * 
 * Data Bytes:
 *  Generated by a 23-bit LFSR, with taps at positions 1 and 23.
 *  The data bytes are an arbitrary fixed 8-bit window on LFSR state.
 * 
 * Sector 6:
 *  First 16 bytes contain signature "Rob Northen Comp"
 * 
 * Timings:
 *  Sync 0x8912 is 5% faster; Sync 0x8914 is 5% slower.
 *  Speed changes occur at start of preceding sector's gap.
 */
```

### 2.2 LFSR Implementation

```c
// 23-bit LFSR with taps at positions 1 and 23
static uint32_t lfsr_next(uint32_t x) {
    return ((x << 1) & ((1u << 23) - 1)) | (((x >> 22) ^ x) & 1);
}

static uint32_t lfsr_prev(uint32_t x) {
    return (x >> 1) | ((((x >> 1) ^ x) & 1) << 22);
}

static uint8_t lfsr_byte(uint32_t x) {
    return (uint8_t)(x >> 15);  // 8-bit window at bits 22:15
}
```

### 2.3 Sync Markers

```c
static const uint16_t sync_list[] = {
    0x8a91, 0x8a44, 0x8a45, 0x8a51, 0x8912, 0x8911,
    0x8914, 0x8915, 0x8944, 0x8945, 0x8951
};
```

### 2.4 Timing Variation

```c
// Move to next sector's speed to encode track gap
sec++;
speed = (sec == 4 ? (SPEED_AVG * 95) / 100 :   // 5% faster
         sec == 6 ? (SPEED_AVG * 105) / 100 :  // 5% slower
         SPEED_AVG);
tbuf_gap(tbuf, speed, 44*8);
```

**Key Insight:** CopyLock uses timing variation combined with LFSR-generated pseudo-random data. The protection can be fully reconstructed from just the 23-bit LFSR seed!

---

## 3. Speedlock Protection (Variable Density)

### 3.1 Detection Algorithm

```c
static void *speedlock_write_raw(struct disk *d, unsigned int tracknr, 
                                  struct stream *s) {
    // Aggressive PLL settings needed
    s->pll_period_adj_pct = 5;
    s->pll_phase_adj_pct = 60;

    // Get average 32-bits latency
    for (i = 0; i < 2000; i++)
        stream_next_bits(s, 32);
    latency = s->latency / 2000;

    // Scan for long bitcells (longer than +8%)
    do {
        s->latency = 0;
        stream_next_bits(s, 32);
    } while (s->latency < ((latency * 108) / 100));
    offs[0] = s->index_offset_bc;

    // Scan for short bitcells (shorter than -8%)
    do {
        s->latency = 0;
        stream_next_bits(s, 32);
    } while (s->latency > ((latency * 92) / 100));
    offs[1] = s->index_offset_bc;
    
    // ... validation checks ...
}
```

### 3.2 Track Generation

```c
static void speedlock_read_raw(struct disk *d, unsigned int tracknr, 
                                struct tbuf *tbuf) {
    // Normal speed section
    for (i = 0; i < si->seclen; i++)
        tbuf_bits(tbuf, SPEED_AVG, bc_mfm, 8, 0);
    
    // Long bitcells (+10%)
    for (i = 0; i < si->seclen; i++)
        tbuf_bits(tbuf, (SPEED_AVG*110)/100, bc_mfm, 8, 0);
    
    // Short bitcells (-10%)
    for (i = 0; i < si->seclen; i++)
        tbuf_bits(tbuf, (SPEED_AVG*90)/100, bc_mfm, 8, 0);
}
```

---

## 4. Weak Bit Protection (Dungeon Master)

### 4.1 Protection Concept

```c
/*
 * The protection relies on an ambiguous flux transition at the edge of the
 * FDC's inspection window, which may be interpreted as clock or as data.
 * Thus the MSB of each byte in the weak area is randomly read as 0 or 1.
 * 
 * Note that this relies on fairly authentic PLL behaviour in the flux
 * decoder, to respond slowly to 'out of sync' pulses. Else we can lose
 * sync with the bit stream.
 */
```

### 4.2 Detection (Reading)

```c
// Check each flakey byte is read as 0x68 or 0xE8
for (i = 20; i < 509; i++) {
    dat[i] &= 0x7f;  // Mask off random MSB
    if (dat[i] != 0x68)
        break;
}
```

### 4.3 Generation (Writing)

```c
if (tbuf->weak != NULL) {
    // IPF: Explicitly randomise occasional MSBs
    for (i = 20; i < 20+16*30; i += 16) {
        tbuf_bytes(tbuf, SPEED_AVG, bc_mfm, 7, &dat[sec*512+i]);
        tbuf_weak(tbuf, 1);  // ← WEAK BIT MARKER
        tbuf_bits(tbuf, SPEED_AVG, bc_mfm, 7, 0x68);
        tbuf_bytes(tbuf, SPEED_AVG, bc_mfm, 8, &dat[sec*512+i+8]);
    }
} else {
    // Default: generate accurate flux timings
    for (i = 20, j = 0; i < 20+16*30; i++) {
        // Create timing jitter to produce ambiguous reads
        delta = (((SPEED_AVG*7)/10) * (j < 15 ? j : 30 - j)) / 15;
        if (j++ == 30) j = 0;
        tbuf_bits(tbuf, SPEED_AVG+delta, bc_raw, 1, 1);
        tbuf_bits(tbuf, SPEED_AVG-delta, bc_raw, 1, 0);
        tbuf_bits(tbuf, SPEED_AVG, bc_mfm, 7, 0x68);
    }
}
```

---

## 5. Long Track Protections

### 5.1 PROTEC Long Track

```c
/* TRKTYP_protec_longtrack:
 *  u16 0x4454
 *  u8 0x33 (encoded in-place, 1000+ times, to track gap)
 *  Track is checked to be >= 107200 bits long
 *  Protection checks for >= 6700 raw words between sync marks
 */

static void *protec_longtrack_write_raw(...) {
    while (stream_next_bit(s) != -1) {
        if ((s->word >> 16) != info->sync)
            continue;
        byte = (uint8_t)mfm_decode_word(s->word);
        if (!check_sequence(s, 1000, byte))
            continue;
        if (!check_length(s, 107200))  // Minimum 107200 bits!
            break;
        ti->total_bits = 110000;  // Long enough
        // ...
    }
}
```

### 5.2 All 36+ Long Track Variants

| Handler | Sync | Min Bits | Notes |
|---------|------|----------|-------|
| protec_longtrack | 0x4454 | 107200 | PROTEC standard |
| protec_alt_longtrack | 0x924a | 107200 | PROTEC variant |
| protoscan_longtrack | 0x4124 | 102400 | Lotus I/II |
| tiertex_longtrack | 0x4124 | 99328-103680 | Strider II |
| silmarils_longtrack | 0xa144 | 104128 | "ROD0" signature |
| lankhor1_longtrack | 0xa144 | 104128 | "PUTE" signature |
| lankhor2_longtrack | 0xa144 | 104128 | "geni" signature |
| infogrames_longtrack | 0x4489 | 105500 | Hostages |
| prolance_longtrack | 0x4454 | 105500 | B.A.T. |
| sevencities_longtrack | 0x4891 | 105500 | Seven Cities |
| gauntlet2_longtrack | 0x4489 | 105500 | Gauntlet II |
| bomb_busters_longtrack | 0x9254 | 106600 | Bomb Busters |
| xelok_longtrack | 0x8914 | 105500 | Xelok |
| tennis_cup_longtrack | 0x4489 | 104000 | Tennis Cup |
| ... | ... | ... | 20+ more variants |

---

## 6. IPF Container - Weak Bit Encoding

### 6.1 Chunk Codes

```c
enum chkcode { 
    chkEnd=0,    // End of data stream
    chkSync,     // Sync mark (raw bits)
    chkData,     // MFM-encoded data
    chkGap,      // Gap data
    chkRaw,      // Raw bitstream
    chkFlaky     // WEAK/FLAKEY BITS!
};
```

### 6.2 Weak Bit Handler

```c
static void ipf_tbuf_weak(struct tbuf *tbuf, unsigned int bits) {
    struct ipf_tbuf *ibuf = container_of(tbuf, struct ipf_tbuf, tbuf);
    
    ipf_tbuf_finish_chunk(ibuf, chkFlaky);
    ibuf->decoded_bits += 2*bits;
    ibuf->len += bits/8;
    ibuf->bits = bits&7;
}
```

### 6.3 Image Flags

```c
#define IMGF_FLAKEY (1u<<0)  // Track contains weak bits

struct ipf_img {
    // ...
    uint32_t flags;    // 0 (unless weak bits → IMGF_FLAKEY)
    // ...
};
```

---

## 7. Notable Protection Implementations

### 7.1 Top Files by Size

| File | LOC | Protection Type |
|------|-----|-----------------|
| longtrack.c | 1,845 | 36+ long track variants |
| thalion.c | 974 | Thalion Software |
| soft_touch.c | 612 | Soft Touch protection |
| amigados.c | 571 | Standard AmigaDOS + variants |
| readysoft.c | 567 | ReadySoft (Dragon's Lair) |
| copylock.c | 433 | Rob Northen CopyLock |
| ubi_protection.c | 426 | Ubisoft protection |

### 7.2 Protection Categories

**LFSR-Based:**
- CopyLock (Rob Northen) - 23-bit LFSR
- Speedlock - timing variation

**Weak Bits:**
- Dungeon Master / Chaos Strikes Back
- Anco/Kingsoft weak protection

**Long Tracks:**
- 36+ variants in longtrack.c
- Track lengths from 99,328 to 111,000 bits

**Custom Formats:**
- 194 game-specific handlers
- Psygnosis A/B/C, Factor5, Thalion, etc.

---

## 8. Integration Recommendations for UFT

### 8.1 Immediate Priority (P0)

| Module | Source | Effort | Impact |
|--------|--------|--------|--------|
| tbuf_weak() API | private/disk.h | 1 day | Enable weak bit marking |
| CopyLock LFSR | copylock.c | 2 days | Complete Rob Northen support |
| Speedlock detection | speedlock.c | 1 day | Variable density detection |

### 8.2 High Priority (P1)

| Module | Source | Effort | Impact |
|--------|--------|--------|--------|
| Long track framework | longtrack.c | 3 days | 36+ protection types |
| IPF chkFlaky | container/ipf.c | 1 day | IPF weak bit export |
| Dungeon Master weak | dungeon_master.c | 2 days | Timing-based weak bits |

### 8.3 Data Structures to Adopt

```c
// Speed constants (from disk-utilities)
#define SPEED_AVG 1000  // Base speed unit

// Weak bit flag in track info
#define IMGF_FLAKEY (1u<<0)

// Bitcell encoding types (already similar in UFT)
enum bitcell_encoding {
    bc_raw,
    bc_mfm,
    bc_mfm_even,
    bc_mfm_odd,
    bc_mfm_even_odd,
    bc_mfm_odd_even
};
```

---

## 9. Comparison: MAME vs Disk-Utilities

| Aspect | MAME | Disk-Utilities |
|--------|------|----------------|
| Focus | Multi-platform emulation | Amiga preservation |
| Amiga formats | ~5 | **194** |
| Protection types | ~20 | **456** |
| Weak bit support | MG_N/MG_D | tbuf_weak() |
| Long tracks | Basic | **36+ variants** |
| CopyLock | Basic | **Complete with timing** |
| Code style | C++ | C (C99 compatible) |
| License | BSD-3 | Public Domain |

**Verdict:** Use disk-utilities for Amiga protection, MAME for cross-platform basics.

---

## 10. Key Algorithms to Extract

### 10.1 LFSR (CopyLock)
- 23-bit with taps at 1, 23
- Forward/backward traversal
- Sector-to-sector state calculation

### 10.2 Long Track Detection
- Sync pattern matching
- Minimum bit count validation
- Signature verification ("ROD0", "PUTE", etc.)

### 10.3 Variable Density Detection
- Latency-based bitcell measurement
- ±8% threshold for speed zones
- PLL tuning requirements (5% period, 60% phase)

### 10.4 Weak Bit Generation
- Timing jitter approach (authentic)
- Explicit weak bit marking (IPF)
- MSB randomization pattern

---

## 11. Conclusion

Disk-utilities is an **essential resource** for UFT's copy protection support:

1. **456 track types** - The most comprehensive protection database
2. **Production-quality code** - Battle-tested implementations
3. **C99 compatible** - Direct integration possible
4. **Public domain** - No licensing concerns

**Recommended Integration Order:**
1. tbuf_weak() API pattern
2. CopyLock LFSR + timing
3. Speedlock variable density
4. Long track framework
5. Game-specific handlers (as needed)

The combination of **MAME** (cross-platform infrastructure) and **disk-utilities** (Amiga specialization) provides complete coverage for UFT's copy protection goals.

---

*Generated by UFT Disk-Utilities Analysis Pipeline*
